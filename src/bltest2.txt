/*
 * Mobile Robot BlueDot Control System - Arduino Controller
 * Description: Receives commands from Raspberry Pi and controls OMNI-3MD motor driver
 * 
 * Hardware:
 * - Arduino Mega 2560
 * - OMNI-3MD motor controller (I2C address 0x30)
 * - 3 DC motors with encoders
 * 
 * Libraries Required:
 * - Wire (I2C communication)
 * - BnrOmni (OMNI-3MD control library)
 * 
 * Command Format from Raspberry Pi:
 * - MOVE:speed,rotation,direction,distance
 * - SPEED:value
 * - STOP
 * - STOP_SMOOTH  
 * - EMERGENCY_STOP
 * - REBOOT
 */

#include <Arduino.h>
#include <Wire.h>
#include <BnrOmni.h>
#include <avr/wdt.h>

// OMNI-3MD Configuration
#define OMNI3MD_ADDRESS 0x30
BnrOmni omni;

// Serial Communication
#define SERIAL_BAUD 115200
#define MAX_COMMAND_LENGTH 64
#define COMMAND_TIMEOUT 500  // 500ms timeout for I2C commands

// Movement Parameters
int current_speed = 50;        // Current speed setting (0-100)
int target_linear_speed = 0;   // Target linear speed
int target_rotation_speed = 0; // Target rotation speed  
int target_direction = 0;      // Target direction (0-360)
int move_distance = 0;         // Distance to move

// Smooth Movement Control
unsigned long last_movement_time = 0;
unsigned long movement_update_interval = 50; // 50ms update rate
bool smooth_stopping = false;
int stop_deceleration_rate = 5; // Speed reduction per update cycle

// Command Processing
String input_buffer = "";
bool command_ready = false;
unsigned long last_command_time = 0;
unsigned long command_timeout = 1000; // 1 second command timeout

// Safety and Status
bool emergency_stop_active = false;
bool system_initialized = false;
unsigned long heartbeat_time = 0;
unsigned long heartbeat_interval = 1000; // 1 second status updates

// Performance monitoring
unsigned long loop_count = 0;
unsigned long performance_report_time = 0;

void initialize_omni3md() {
  Serial.print("Initializing OMNI-3MD...");

  // Connect to OMNI-3MD via I2C
  omni.i2cConnect(OMNI3MD_ADDRESS);
  delay(100);

  // Test communication
  float firmware_version = omni.readFirmware();
  if (firmware_version > 0) {
    Serial.print(" OK (Firmware: ");
    Serial.print(firmware_version);
    Serial.println(")");
  } else {
    Serial.println(" FAILED!");
    Serial.println("ERROR: Cannot communicate with OMNI-3MD");
    Serial.println("Check I2C connections and address");
    while (1) {
      delay(1000); // Halt execution if OMNI-3MD not found
    }
  }
}

void configure_robot_parameters() {
  Serial.print("Configuring robot parameters...");

  // Set I2C timeout for safety (500ms)
  omni.setI2cTimeout(50);
  delay(50);

  // Configure PID parameters for smooth movement
  // These values may need tuning based on your specific robot
  omni.setPid(650, 450, 250); // Kp, Ki, Kd
  delay(100);

  // Configure acceleration ramp for smooth starts
  omni.setRamp(35, 950); // slope, Kl
  delay(50);

  // Set encoder prescalers (adjust based on your encoders)
  omni.setEncPrescaler(1, 1); // Motor 1, prescaler = 10
  omni.setEncPrescaler(2, 1); // Motor 2, prescaler = 10
  omni.setEncPrescaler(3, 1); // Motor 3, prescaler = 10
  delay(100);

  Serial.println(" Done");
}

void initialize_safety() {
  Serial.print("Initializing safety systems...");

  // Enable watchdog timer for automatic reset if system hangs
  wdt_enable(WDTO_4S); // 4 second watchdog timeout

  emergency_stop_active = false;

  Serial.println(" Done");
}

void execute_omnidirectional_movement() {
  // Use OMNI-3MD's built-in omnidirectional movement function
  omni.movOmni(target_linear_speed, target_rotation_speed, target_direction);
}

void handle_move_command(String command) {
  if (emergency_stop_active) {
    Serial.println("ERROR:EMERGENCY_STOP_ACTIVE");
    return;
  }

  // Parse MOVE:speed,rotation,direction,distance
  String params = command.substring(5); // Remove "MOVE:"

  int comma1 = params.indexOf(',');
  int comma2 = params.indexOf(',', comma1 + 1);
  int comma3 = params.indexOf(',', comma2 + 1);

  if (comma1 == -1 || comma2 == -1 || comma3 == -1) {
    Serial.println("ERROR:INVALID_MOVE_FORMAT");
    return;
  }

  target_linear_speed = params.substring(0, comma1).toInt();
  target_rotation_speed = params.substring(comma1 + 1, comma2).toInt();
  target_direction = params.substring(comma2 + 1, comma3).toInt();
  move_distance = params.substring(comma3 + 1).toInt();

  // Validate parameters
  target_linear_speed = constrain(target_linear_speed, 0, 100);
  target_rotation_speed = constrain(target_rotation_speed, -100, 100);
  target_direction = constrain(target_direction, 0, 360);
  move_distance = constrain(move_distance, 0, 1000);

  // Execute movement
  execute_omnidirectional_movement();

  Serial.print("MOVE_OK:speed=");
  Serial.print(target_linear_speed);
  Serial.print(",rot=");
  Serial.print(target_rotation_speed);
  Serial.print(",dir=");
  Serial.print(target_direction);
  Serial.print(",dist=");
  Serial.println(move_distance);
}

void handle_speed_command(String command) {
  // Parse SPEED:value
  int new_speed = command.substring(6).toInt(); // Remove "SPEED:"

  current_speed = constrain(new_speed, 1, 100);

  Serial.print("SPEED_SET:");
  Serial.println(current_speed);
}

void handle_stop_command() {
  target_linear_speed = 0;
  target_rotation_speed = 0;
  smooth_stopping = false;

  omni.stop();

  Serial.println("STOPPED");
}

void handle_smooth_stop_command() {
  smooth_stopping = true;
  Serial.println("SMOOTH_STOP_INITIATED");
}

void handle_emergency_stop() {
  emergency_stop_active = true;
  target_linear_speed = 0;
  target_rotation_speed = 0;
  smooth_stopping = false;

  omni.stop();

  Serial.println("EMERGENCY_STOP:ACTIVE");
  Serial.println("Send 'SPEED:X' command to reset emergency stop");
}

void handle_reboot_command() {
  Serial.println("REBOOTING_ARDUINO...");
  Serial.flush();
  delay(100);

  // Software reset using watchdog timer
  wdt_enable(WDTO_60MS);
  while (1) {
    // Wait for watchdog reset
  }
}

void update_movement_control() {
  unsigned long current_time = millis();

  if (current_time - last_movement_time >= movement_update_interval) {
    last_movement_time = current_time;

    // Handle smooth stopping
    if (smooth_stopping) {
      if (target_linear_speed > 0) {
        target_linear_speed = max(0, target_linear_speed - stop_deceleration_rate);
        execute_omnidirectional_movement();

        if (target_linear_speed == 0) {
          smooth_stopping = false;
          omni.stop();
          Serial.println("SMOOTH_STOP_COMPLETE");
        }
      } else {
        smooth_stopping = false;
      }
    }
  }
}

void monitor_safety_systems() {
  // Reset watchdog timer regularly during normal operation
  wdt_reset();

  // Check for communication timeout
  if (millis() - last_command_time > command_timeout && last_command_time > 0) {
    // No commands received recently - stop for safety
    if (target_linear_speed > 0 || target_rotation_speed != 0) {
      Serial.println("WARNING:COMMAND_TIMEOUT");
      handle_stop_command();
    }
  }

  // Reset emergency stop when speed is set
  if (emergency_stop_active && current_speed > 0) {
    emergency_stop_active = false;
    Serial.println("EMERGENCY_STOP:RESET");
  }
}

int get_free_memory() {
  extern int __heap_start, *__brkval;
  int v;
  return (int) &v - (__brkval == 0 ? (int) &__heap_start : (int) __brkval);
}

void send_status_updates() {
  unsigned long current_time = millis();

  if (current_time - heartbeat_time >= heartbeat_interval) {
    heartbeat_time = current_time;

    // Basic status
    Serial.print("STATUS:speed=");
    Serial.print(current_speed);
    Serial.print(",emergency=");
    Serial.print(emergency_stop_active ? "true" : "false");
    Serial.print(",uptime=");
    Serial.println(current_time / 1000);
  }

  // Performance report every 10 seconds
  if (current_time - performance_report_time >= 10000) {
    performance_report_time = current_time;

    Serial.print("PERFORMANCE:loops_per_sec=");
    Serial.print(loop_count / 10);
    Serial.print(",free_ram=");
    Serial.println(get_free_memory());

    loop_count = 0;
  }
}

void send_detailed_status() {
  Serial.println("=== DETAILED STATUS ===");
  Serial.print("Speed: "); Serial.println(current_speed);
  Serial.print("Target Linear Speed: "); Serial.println(target_linear_speed);
  Serial.print("Target Rotation Speed: "); Serial.println(target_rotation_speed);
  Serial.print("Target Direction: "); Serial.println(target_direction);
  Serial.print("Emergency Stop: "); Serial.println(emergency_stop_active ? "ACTIVE" : "INACTIVE");
  Serial.print("Smooth Stopping: "); Serial.println(smooth_stopping ? "YES" : "NO");
  Serial.print("System Initialized: "); Serial.println(system_initialized ? "YES" : "NO");
  Serial.print("Uptime: "); Serial.print(millis() / 1000); Serial.println(" seconds");
  Serial.print("Free RAM: "); Serial.print(get_free_memory()); Serial.println(" bytes");

  // OMNI-3MD status
  float battery = omni.readBattery();
  float temperature = omni.readTemperature();
  Serial.print("Battery Voltage: "); Serial.print(battery); Serial.println("V");
  Serial.print("Controller Temperature: "); Serial.print(temperature); Serial.println("Â°C");
  Serial.println("=======================");
}

void process_command(String command) {
  // Reset watchdog timer on command receipt
  wdt_reset();

  Serial.print("Received: ");
  Serial.println(command);

  command.toUpperCase();
  command.trim();

  if (command.startsWith("MOVE:")) {
    handle_move_command(command);
  } 
  else if (command.startsWith("SPEED:")) {
    handle_speed_command(command);
  }
  else if (command == "STOP") {
    handle_stop_command();
  }
  else if (command == "STOP_SMOOTH") {
    handle_smooth_stop_command();
  }
  else if (command == "EMERGENCY_STOP") {
    handle_emergency_stop();
  }
  else if (command == "REBOOT") {
    handle_reboot_command();
  }
  else if (command == "STATUS") {
    send_detailed_status();
  }
  else {
    Serial.print("ERROR:UNKNOWN_COMMAND:");
    Serial.println(command);
  }
}

void process_serial_input() {
  // Read incoming serial data
  while (Serial.available() > 0) {
    char received_char = Serial.read();

    if (received_char == '\n' || received_char == '\r') {
      if (input_buffer.length() > 0) {
        command_ready = true;
        last_command_time = millis();
      }
    } else if (received_char >= 32 && received_char <= 126) { // Printable characters only
      if (input_buffer.length() < MAX_COMMAND_LENGTH) {
        input_buffer += received_char;
      } else {
        // Buffer overflow protection
        Serial.println("ERROR:COMMAND_TOO_LONG");
        input_buffer = "";
      }
    }
  }

  // Process completed command
  if (command_ready) {
    process_command(input_buffer);
    input_buffer = "";
    command_ready = false;
  }
}

void setup() {
  // Initialize serial communication
  Serial.begin(SERIAL_BAUD);
  while (!Serial) {
    ; // Wait for serial port to connect
  }

  Serial.println("=================================");
  Serial.println("MOBILE ROBOT CONTROLLER STARTING");
  Serial.println("=================================");

  // Initialize I2C and OMNI-3MD
  initialize_omni3md();

  // Configure initial parameters
  configure_robot_parameters();

  // Initialize safety systems
  initialize_safety();

  system_initialized = true;

  Serial.println("System ready - waiting for commands...");
  Serial.println("Commands: MOVE, SPEED, STOP, STOP_SMOOTH, EMERGENCY_STOP, REBOOT");
  Serial.println("=================================\n");

  // Send ready signal to Raspberry Pi
  Serial.println("STATUS:READY");
}

void loop() {
  // Process incoming serial commands
  process_serial_input();

  // Handle movement updates
  if (!emergency_stop_active && system_initialized) {
    update_movement_control();
  }

  // Safety monitoring
  monitor_safety_systems();

  // Status reporting
  send_status_updates();

  // Performance monitoring
  loop_count++;

  // Small delay to prevent overwhelming the system
  delay(10);
}